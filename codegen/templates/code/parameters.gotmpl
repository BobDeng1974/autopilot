// the parameters package makes it easy to interact with input/output types for your phases
// it also handles registering the types with the kubernetes runtime.Scheme
package parameters

import (
{{- range $param := unique_params }}
    {{- if not (is_metrics $param) }}
    {{ $param.ImportPrefix }} "{{ $param.Package }}"
    {{- end}}
{{- end}}

    "k8s.io/apimachinery/pkg/runtime"
)

type (
{{- range $param := unique_params }}
    {{- if not (is_metrics $param) }}

    // type aliases for {{ $param.ImportPrefix }}.{{$param.SingleName}}
    {{$param.SingleName}} = {{ $param.ImportPrefix }}.{{$param.SingleName}}
    {{$param.PluralName}} = {{ $param.ImportPrefix }}.{{$param.SingleName}}List

    {{- end}}
{{- end }}
)

var (
    SchemeBuilder = runtime.SchemeBuilder{}
)

func init() {

{{- $schemesAdded := ""}}

{{- range $param := unique_params }}
    {{- if $param.IsCrd }}
        {{- if not (string_contains $schemesAdded $param.ImportPrefix) }}
    SchemeBuilder = append(SchemeBuilder, {{ $param.ImportPrefix }}.AddToScheme)
        {{- $schemesAdded = (print $schemesAdded "," $param.ImportPrefix) }}
        {{- end}}
    {{- end}}
{{- end}}
}

func AddToScheme(s *runtime.Scheme) error {
    return SchemeBuilder.AddToScheme(s)
}
