package scheduler

import (
    "context"
    "fmt"
    "time"

    "k8s.io/apimachinery/pkg/api/errors"
    "k8s.io/kubernetes/pkg/util/slice"

    ctl "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/handler"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/reconcile"
    logf "sigs.k8s.io/controller-runtime/pkg/log"

    "github.com/solo-io/autopilot/pkg/ezkube"
    "github.com/solo-io/autopilot/pkg/metrics"
    "github.com/solo-io/autopilot/pkg/utils"

    {{.Version}} "{{.TypesImportPath}}"

    config "{{.ConfigImportPath}}"

{{- if $.EnableFinalizer }}
    finalizer "{{.FinalizerImportPath}}"
{{- end}}

{{- range $phase := .Phases }}
    {{- range $param := $phase.Outputs }}
    {{$param.ImportPrefix}} "{{$param.Package}}"
    {{- end}}
{{- end}}

{{- range $phase := .Phases}}
    {{- if or (has_inputs $phase) (has_outputs $phase) }}
    {{worker_import_prefix $phase}} "{{worker_package $phase}}"
    {{- end}}
{{- end}}
)

var log = logf.Log.WithName("scheduler")

func AddToManager(ctx context.Context, mgr manager.Manager, namespace string) error {
    scheduler, err := NewScheduler(ctx, mgr, namespace)
    if err != nil {
    	return err
    }
    // Create a new controller
    c, err := controller.New("{{.KindLowerCamel}}-controller", mgr, controller.Options{Reconciler: scheduler})
    if err != nil {
        return err
    }

    // Watch for changes to primary resource {{.Kind}}
    log.Info("Registering watch for primary resource {{.Kind}}")
    err = c.Watch(&source.Kind{Type: &{{$.Version}}.{{$.Kind}}{}}, &handler.EnqueueRequestForObject{})
    if err != nil {
        return err
    }

{{- range $param := unique_outputs }}

    // Watch for changes to secondary resource {{$param.PluralName }} and requeue the owner {{$.Kind}}
    log.Info("Registering watch for primary resource secondary resource {{$param.PluralName }}")
    err = c.Watch(&source.Kind{Type: &{{$param.ImportPrefix }}.{{$param.SingleName }}{}}, &handler.EnqueueRequestForOwner{
        IsController: true,
        OwnerType:    &{{$.Version}}.{{$.Kind}}{},
    })
    if err != nil {
        return err
    }
{{- end}}

    return nil

}

var WorkInterval = config.WorkInterval

{{- if $.EnableFinalizer }}
var FinalizerName = "{{$.KindLower}}-finalizer"
{{- end}}

type Scheduler struct {
    ctx context.Context
    mgr manager.Manager
    Metrics metrics.Metrics
    namespace string
}

func NewScheduler(ctx context.Context, mgr manager.Manager, namespace string ) (*Scheduler, error) {
    metricsFactory, err := metrics.NewFactory(config.MetricsServer, config.MeshProvider, time.Second * 30)
    if err != nil {
    	return nil, err
    }

    return &Scheduler{
    	ctx:       ctx,
    	mgr:       mgr,
        Metrics:   metricsFactory.Observer(),
        namespace: namespace,
    }, nil
}

func (s *Scheduler) Reconcile(request reconcile.Request) (reconcile.Result, error) {
    result := reconcile.Result{RequeueAfter: WorkInterval}

    {{$.KindLowerCamel}} := &{{$.Version}}.{{$.Kind}}{}
    {{$.KindLowerCamel}}.Namespace = request.Namespace
    {{$.KindLowerCamel}}.Name = request.Name

    client := ezkube.NewClient(s.mgr)

    if err := client.Get(s.ctx, {{$.KindLowerCamel}}); err != nil {
        // garbage collection and finalizers should handle cleaning up after deletion
        if errors.IsNotFound(err) {
            return result, nil
        }
        return result, err
    }

    {{- if $.EnableFinalizer }}
    // examine DeletionTimestamp to determine if object is under deletion
    if {{$.KindLowerCamel}}.DeletionTimestamp.IsZero() {
        // The object is not being deleted, so if it does not have our finalizer,
        // then lets add the finalizer and update the object. This is equivalent
        // registering our finalizer.
        if !utils.ContainsString({{$.KindLowerCamel}}.Finalizers, FinalizerName) {
            {{$.KindLowerCamel}}.Finalizers = append({{$.KindLowerCamel}}.Finalizers, FinalizerName)
            if err := client.Ensure(s.ctx, nil, {{$.KindLowerCamel}}); err != nil {
                return result, err
            }
        }
    } else {
        // The object is being deleted
        if utils.ContainsString({{$.KindLowerCamel}}.Finalizers, FinalizerName) {
            // our finalizer is present, so lets handle any external dependency
            if err := (&finalizer.Finalizer{Client: client}).Finalize(s.ctx, {{$.KindLowerCamel}}); err != nil {
                // if fail to delete the external dependency here, return with error
                // so that it can be retried
                return result, err
            }

            // remove our finalizer from the list and update it.
            {{$.KindLowerCamel}}.Finalizers = utils.RemoveString({{$.KindLowerCamel}}.Finalizers, FinalizerName)
            if err := client.Ensure(s.ctx, nil, {{$.KindLowerCamel}}); err != nil {
                return result, err
            }
        }

        return result, nil
    }
    {{- end}}

    switch {{$.KindLowerCamel}}.Status.Phase {
{{- range $phase := .Phases}}
    {{- if $phase.Initial }}
    case "", {{$.Version}}.{{$.Kind}}Phase{{$phase.Name}}:
    {{- else }}
    case {{$.Version}}.{{$.Kind}}Phase{{$phase.Name}}:
    {{- end}}
        log.Info("Syncing {{$.Kind}} %v in phase {{$phase.Name}}", {{$.KindLowerCamel}}.Name)

    {{- if is_final $phase }}
        // end state, do not requeue
        return reconcile.Result{}, nil
    {{- else }}

        {{- if has_inputs $phase }}
		inputs, err := s.make{{ $phase.Name}}Inputs(client)
		if err != nil {
			return result, err
		}

            {{- if has_outputs $phase }}
        outputs, nextPhase, statusInfo, err := (&{{worker_import_prefix $phase}}.Worker{Client:client}).Sync(s.ctx, {{$.KindLowerCamel}}, inputs)
		if err != nil {
			return result, err
		}
            {{- else}}
        nextPhase, statusInfo, err := (&{{worker_import_prefix $phase}}.Worker{Client:client}).Sync(s.ctx, {{$.KindLowerCamel}}, inputs)
		if err != nil {
			return result, err
		}

            {{- end}}

        {{- else}}
            {{- if has_outputs $phase }}
        outputs, nextPhase, statusInfo, err := (&{{worker_import_prefix $phase}}.Worker{Client:client}).Sync(s.ctx, {{$.KindLowerCamel}})
		if err != nil {
			return result, err
		}
            {{- else}}
        nextPhase, statusInfo, err := (&{{worker_import_prefix $phase}}.Worker{Client:client}).Sync(s.ctx, {{$.KindLowerCamel}})
		if err != nil {
			return result, err
		}
            {{- end}}
        {{- end}}

        {{- range $out := $phase.Outputs }}
		for _, out := range outputs.{{ $out.PluralName }}.Items {
			if err := client.Ensure(s.ctx, {{$.KindLowerCamel}}, &out); err != nil {
				return result, err
			}
		}
        {{- end}}

        {{$.KindLowerCamel}}.Status.Phase = nextPhase
        if  statusInfo != nil {
            {{$.KindLowerCamel}}.Status.{{$.Kind}}StatusInfo = *statusInfo
        }
		if err := client.UpdateStatus(s.ctx, {{$.KindLowerCamel}}); err != nil {
			return result, err
		}

        return result, err
        {{- end}}
    {{- end}}
    }
    return result, fmt.Errorf("cannot process {{.Kind}} in unknown phase: %v", {{$.KindLowerCamel}}.Status.Phase)
}

{{- range $phase := .Phases}}
    {{- if has_inputs $phase }}

func (s *Scheduler) make{{ $phase.Name}}Inputs(client ezkube.Client) ({{worker_import_prefix $phase}}.Inputs, error) {
	var (
		inputs {{worker_import_prefix $phase}}.Inputs
	    err error
    )

        {{- range $param := $phase.Inputs }}
            {{- if is_metrics $param }}
    inputs.{{$param.PluralName}} = s.Metrics
            {{- else}}
    err = client.List(s.ctx, &inputs.{{$param.PluralName}}, ctl.InNamespace(s.namespace))
    if err != nil {
        return inputs, err
    }
            {{- end}}
        {{- end}}

    return inputs, err
}
{{- end}}
{{- end}}
