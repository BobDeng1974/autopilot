package initializing

import (
	"context"
	"fmt"
	"github.com/go-logr/logr"
	"github.com/solo-io/autopilot/pkg/ezkube"
	"github.com/solo-io/autopilot/test/e2e/test/pkg/parameters"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"strings"
	"time"

	v1 "github.com/solo-io/autopilot/test/e2e/test/pkg/apis/tests/v1"
)

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!

type Worker struct {
	Client ezkube.Client
	Logger logr.Logger
}

const loadTesterImage = "docker.io/rcmorano/docker-hey"

func (w *Worker) Sync(ctx context.Context, test *v1.Test) (Outputs, v1.TestPhase, *v1.TestStatusInfo, error) {
	w.Logger.Info("initializing deployment", "name", test.Name)

	heyArgs := heyCommand{
		Name:      test.Name,
		Namespace: test.Namespace,
		Duration:  test.Spec.Duration.Duration,
		Port:      test.Spec.Port,
		LoadTest:  test.Spec.LoadTest,

		// terminate envoy pod
		// https://medium.com/redbox-techblog/handling-istio-sidecars-in-kubernetes-jobs-c392661c4af7
		KillEnvoy: true,
	}.args()

	loadTest := test.Name + "-loadtester"

	appLabels := map[string]string{"app": test.Name}
	loadTestLabels := map[string]string{"app": loadTest}
	return Outputs{
		Deployments: parameters.Deployments{
			Items: []appsv1.Deployment{
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      test.Name,
						Namespace: test.Namespace,
					},
					Spec: appsv1.DeploymentSpec{
						Selector: &metav1.LabelSelector{
							MatchLabels: appLabels,
						},
						Template: corev1.PodTemplateSpec{
							ObjectMeta: metav1.ObjectMeta{
								Name:   test.Name,
								Labels: appLabels,
							},
							Spec: test.Spec.PodSpec,
						}},
				},
				{
					ObjectMeta: metav1.ObjectMeta{
						Name:      loadTest,
						Namespace: test.Namespace,
					},
					Spec: appsv1.DeploymentSpec{
						Selector: &metav1.LabelSelector{
							MatchLabels: loadTestLabels,
						},
						Template: corev1.PodTemplateSpec{
							ObjectMeta: metav1.ObjectMeta{
								Name:   test.Name,
								Labels: loadTestLabels,
							},
							Spec: corev1.PodSpec{
								Containers: []corev1.Container{{
									Name:            "hey",
									Image:           loadTesterImage,
									Command:         heyArgs,
									ImagePullPolicy: corev1.PullAlways,
								}},
								RestartPolicy: corev1.RestartPolicyAlways,
							},
						}},
				},
			},
		},
		Services: parameters.Services{
			Items: []corev1.Service{{
				ObjectMeta: metav1.ObjectMeta{
					Name:      test.Name,
					Namespace: test.Namespace,
				},
				Spec: corev1.ServiceSpec{
					Selector: appLabels,
					Ports: []corev1.ServicePort{{
						Port: test.Spec.Port,
					}},
				},
			}},
		},
	},
		v1.TestPhaseProcessing,
		&v1.TestStatusInfo{TimeStarted: metav1.Now()},
		nil
}

type heyCommand struct {
	Name      string
	Namespace string
	Duration  time.Duration
	Port      int32
	v1.LoadTest

	KillEnvoy bool
}

func (a heyCommand) args() []string {
	if a.Method == "" {
		a.Method = "GET"
	}
	if a.Scheme == "" {
		a.Scheme = "http"
	}
	url := fmt.Sprintf("%v://%v.%v:%v%v", a.Scheme, a.Name, a.Namespace, a.Port, a.Path)

	args := []string{
		"hey",
		"-m", a.Method,
		"-z", a.Duration.String(),
	}

	if a.Concurrency != 0 {
		args = append(args,
			"-c", fmt.Sprintf("%v", a.Concurrency))
	}

	args = append(args, a.ExtraArgs...)
	args = append(args, url)

	if a.KillEnvoy {
		shellScript := strings.Join(args, " ") + " && pkill -f /usr/local/bin/pilot-agent"
		args = []string{
			"sh", "-c",
			shellScript,
		}
	}

	return args
}
